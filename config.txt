å†…å­˜æ± è¯Šæ–­æŠ¥å‘Šè¯¦ç»†è§£æ
1. å†…å­˜æ± åˆå§‹åŒ–ï¼ˆ1 MBï¼‰
plaintext
Memory pool created (1 MB)
==== Memory Pool Diagnostics ====
Total pool size: 1048576 bytes
Used by allocations: 0 bytes (0 blocks)
Available free memory: 1048536 bytes (1 blocks)
Management overhead: 40 bytes
Unallocated/fragmented: 0 bytes
Fragmentation: 0%
Largest free block: 1048536 bytes
================================
æ€»å†…å­˜æ± å¤§å°ï¼š1 MB (1048576 å­—èŠ‚)

ç”¨æˆ·åˆ†é…ï¼š0 å­—èŠ‚ï¼ˆå°šæœªåˆ†é…ä»»ä½•å†…å­˜ï¼‰

å¯ç”¨ç©ºé—²å†…å­˜ï¼š1048536 å­—èŠ‚ï¼ˆæ€»å†…å­˜å‡å»æ§åˆ¶ç»“æ„ï¼‰

ç®¡ç†å¼€é”€ï¼š40 å­—èŠ‚ï¼ˆå•ä¸ª MemoryBlock ç»“æ„ä½“å¤§å°ï¼‰

æœ€å¤§ç©ºé—²å—ï¼š1048536 å­—èŠ‚ï¼ˆæ•´ä¸ªç©ºé—²åŒºåŸŸï¼‰

ç¢ç‰‡ç‡ï¼š0%ï¼ˆå®Œå…¨è¿ç»­çš„å†…å­˜ç©ºé—´ï¼‰

ğŸ’¡ å…³é”®ç‚¹ï¼šåˆå§‹çŠ¶æ€æ•´ä¸ªå†…å­˜æ± ä¸ºå•ä¸ªè¿ç»­ç©ºé—²å—ï¼Œæ§åˆ¶ç»“æ„å ç”¨ 40 å­—èŠ‚ã€‚

2. åˆ†é…å†…å­˜å—å
plaintext
Allocating memory blocks...
==== Memory Pool Diagnostics ====
Total pool size: 1048576 bytes
Used by allocations: 3968 bytes (5 blocks)
Available free memory: 1044368 bytes (1 blocks)
Management overhead: 240 bytes
Unallocated/fragmented: 0 bytes
Fragmentation: 0%
Largest free block: 1044368 bytes
================================
ç”¨æˆ·åˆ†é…ï¼š3968 å­—èŠ‚ï¼ˆ128+256+512+1024+2048 å­—èŠ‚çš„åˆ†é…ï¼‰

ç®¡ç†å¼€é”€ï¼š240 å­—èŠ‚ï¼ˆ6 ä¸ªå†…å­˜å— Ã— 40 å­—èŠ‚/å—ï¼‰

å¯ç”¨ç©ºé—²å†…å­˜ï¼š1044368 å­—èŠ‚ï¼ˆæ€»å†…å­˜ - ç”¨æˆ·åˆ†é… - ç®¡ç†å¼€é”€ï¼‰

æœ€å¤§ç©ºé—²å—ï¼š1044368 å­—èŠ‚ï¼ˆå‰©ä½™è¿ç»­ç©ºé—´ï¼‰

ç¢ç‰‡ç‡ï¼š0%ï¼ˆç©ºé—²å†…å­˜ä¿æŒè¿ç»­ï¼‰

ğŸ” åˆ†é…ç»†èŠ‚ï¼šæ¯ä¸ªåˆ†é…åŒ…å«ç”¨æˆ·æ•°æ® + æ§åˆ¶ç»“æ„ï¼ˆ40 å­—èŠ‚ï¼‰ï¼Œä½†è¯Šæ–­ä»…æ˜¾ç¤ºç”¨æˆ·æ•°æ®éƒ¨åˆ†ã€‚

3. é‡Šæ”¾éƒ¨åˆ†å†…å­˜å
plaintext
Releasing some allocations...
==== Memory Pool Diagnostics ====
Total pool size: 1048576 bytes
Used by allocations: 2688 bytes (3 blocks)
Available free memory: 1045648 bytes (3 blocks)
Management overhead: 240 bytes
Unallocated/fragmented: 0 bytes
Fragmentation: 0.122412%
Largest free block: 1044368 bytes
================================
ç”¨æˆ·åˆ†é…ï¼š2688 å­—èŠ‚ï¼ˆé‡Šæ”¾äº† 256B å’Œ 1024B å—ï¼‰

ç©ºé—²å—ï¼š3 ä¸ªï¼ˆé‡Šæ”¾çš„å—æœªä¸ä¸»ç©ºé—²åŒºåˆå¹¶ï¼‰

æœ€å¤§ç©ºé—²å—ï¼š1044368 å­—èŠ‚ï¼ˆä¸»ç©ºé—²åŒºï¼‰

ç¢ç‰‡ç‡ï¼š0.122412%ï¼ˆå°ç¢ç‰‡å¯¼è‡´è½»å¾®ç¢ç‰‡åŒ–ï¼‰

ç®¡ç†å¼€é”€ï¼šä¸å˜ï¼ˆæ€»å—æ•°ä»ä¸º 6ï¼‰

âš ï¸ æ³¨æ„ï¼šé‡Šæ”¾çš„ 256B å’Œ 1024B å—æˆä¸ºç‹¬ç«‹ç¢ç‰‡ï¼Œæœªä¸ä¸»ç©ºé—²åŒºåˆå¹¶ã€‚

4. å†æ¬¡åˆ†é…å
plaintext
Allocating more blocks...
==== Memory Pool Diagnostics ====
Total pool size: 1048576 bytes
Used by allocations: 7992 bytes (6 blocks)
Available free memory: 1040224 bytes (3 blocks)
Management overhead: 360 bytes
Unallocated/fragmented: 0 bytes
Fragmentation: 0.0422986%
Largest free block: 1039784 bytes
================================
ç”¨æˆ·åˆ†é…ï¼š7992 å­—èŠ‚ï¼ˆæ–°å¢ 1500B+800B+3000B åˆ†é…ï¼‰

ç®¡ç†å¼€é”€ï¼š360 å­—èŠ‚ï¼ˆ9 ä¸ªå†…å­˜å— Ã— 40 å­—èŠ‚ï¼‰

ç¢ç‰‡ç‡ï¼š0.042%ï¼ˆä¼˜åŒ–åç¢ç‰‡å‡å°‘ï¼‰

æœ€å¤§ç©ºé—²å—ï¼š1039784 å­—èŠ‚ï¼ˆä¸»ç©ºé—²åŒºç¼©å°ï¼‰

ğŸ”„ åŠ¨æ€å˜åŒ–ï¼šæ–°åˆ†é…ä»ä¸»ç©ºé—²åŒºåˆ‡å‰²ï¼Œç¢ç‰‡è¢«éƒ¨åˆ†åˆ©ç”¨ã€‚

5. é‡Šæ”¾æ‰€æœ‰å†…å­˜å
plaintext
Releasing all allocations...
==== Memory Pool Diagnostics ====
Total pool size: 1048576 bytes
Used by allocations: 0 bytes (0 blocks)
Available free memory: 1048536 bytes (1 blocks)
Management overhead: 40 bytes
Unallocated/fragmented: 0 bytes
Fragmentation: 0%
Largest free block: 1048536 bytes
================================
å®Œå…¨æ¢å¤ï¼šçŠ¶æ€ä¸åˆå§‹ä¸€è‡´

ç¢ç‰‡æ¶ˆé™¤ï¼šæ‰€æœ‰å—åˆå¹¶ä¸ºå•ä¸ªè¿ç»­ç©ºé—²åŒº

ç®¡ç†å¼€é”€ï¼š40 å­—èŠ‚ï¼ˆä»…å‰©æ§åˆ¶å—ï¼‰

âœ… éªŒè¯ï¼šå†…å­˜æ± æ­£ç¡®å®ç°å—åˆå¹¶ï¼ˆcoalescingï¼‰åŠŸèƒ½ã€‚

6. å¤§å†…å­˜åˆ†é…æµ‹è¯•
plaintext
Testing large allocation (should fail)...
Expected exception caught: std::bad_alloc

Testing maximum possible allocation...
Large allocation succeeded as expected
==== Memory Pool Diagnostics ====
Total pool size: 1048576 bytes
Used by allocations: 0 bytes (0 blocks)
Available free memory: 1048536 bytes (1 blocks)
Management overhead: 40 bytes
Unallocated/fragmented: 0 bytes
Fragmentation: 0%
Largest free block: 1048536 bytes
================================
è¾¹ç•Œæµ‹è¯•1ï¼šå°è¯•åˆ†é… 1048537 å­—èŠ‚ï¼ˆæœ€å¤§å¯ç”¨+1ï¼‰â†’ å¤±è´¥ï¼ˆç¬¦åˆé¢„æœŸï¼‰

è¾¹ç•Œæµ‹è¯•2ï¼šåˆ†é… 1048536 å­—èŠ‚ï¼ˆæœ€å¤§å¯ç”¨ï¼‰â†’ æˆåŠŸï¼ˆéªŒè¯ç²¾ç¡®å®¹é‡ç®¡ç†ï¼‰

èµ„æºé‡Šæ”¾ï¼šå¤§å—é‡Šæ”¾åå†…å­˜æ± æ¢å¤å®Œæ•´çŠ¶æ€

ğŸ§ª æµ‹è¯•ç»“è®ºï¼šå†…å­˜æ± æ­£ç¡®å¤„ç†è¾¹ç•Œæ¡ä»¶ï¼Œæ— å†…å­˜æ³„æ¼ã€‚


ä»£ç è§£é‡Š


1. å†…å­˜å—æ§åˆ¶ç»“æ„ (MemoryBlock)
cpp
struct MemoryBlock {
    size_t size;            // å—æ€»å¤§å°ï¼ˆåŒ…æ‹¬æ§åˆ¶ç»“æ„ï¼‰
    bool is_free;           // ç©ºé—²æ ‡å¿—
    MemoryBlock* prev;      // ç‰©ç†å‰é©±å—
    MemoryBlock* next;      // ç‰©ç†åç»§å—
    void* data_ptr;         // æ•°æ®åŒºæŒ‡é’ˆ
æ·±åº¦è§£æï¼š

sizeï¼šåŒ…å«æ§åˆ¶å¤´+ç”¨æˆ·æ•°æ®çš„æ€»å¤§å°ï¼Œå•ä½å­—èŠ‚

prev/nextï¼šåŸºäºç‰©ç†åœ°å€é¡ºåºçš„æŒ‡é’ˆï¼ˆéé€»è¾‘é“¾è¡¨ï¼‰ï¼Œç”¨äºå—åˆå¹¶

data_ptrï¼šç”¨æˆ·å®é™…å¯ç”¨çš„å†…å­˜èµ·å§‹ä½ç½®

cpp
    void initialize(size_t block_size, bool free, 
                   MemoryBlock* prev_block, MemoryBlock* next_block) 
    {
        size = block_size;
        is_free = free;
        prev = prev_block;
        next = next_block;
        // è®¡ç®—æ•°æ®åŒºä½ç½®ï¼šå½“å‰åœ°å€ + æ§åˆ¶å¤´å¤§å°
        data_ptr = reinterpret_cast<char*>(this) + sizeof(MemoryBlock);
    }
å…³é”®è®¡ç®—ï¼š

reinterpret_cast<char*>ï¼šå°†æŒ‡é’ˆè½¬ä¸ºå­—èŠ‚çº§æŒ‡é’ˆï¼Œä¾¿äºåœ°å€è®¡ç®—

sizeof(MemoryBlock)ï¼šæ§åˆ¶å¤´å¤§å°ï¼ˆ40å­—èŠ‚ï¼‰ï¼ŒåŒ…å«ï¼š

size_t (8å­—èŠ‚) + bool (1å­—èŠ‚) + ä¸‰ä¸ªæŒ‡é’ˆ (å„8å­—èŠ‚) = 41å­—èŠ‚

å†…å­˜å¯¹é½åå®é™…å ç”¨40å­—èŠ‚ï¼ˆç¼–è¯‘å™¨ä¼˜åŒ–ï¼‰

cpp
    void merge_next() {
        if (next && next->is_free) {
            size += next->size;  // åˆå¹¶å—å¤§å°
            next = next->next;   // æ›´æ–°åç»§æŒ‡é’ˆ
            if (next) {
                next->prev = this;  // æ›´æ–°æ–°åç»§çš„å‰é©±
            }
        }
    }
};
åˆå¹¶ç®—æ³•ï¼š

æ£€æŸ¥åç»§å—æ˜¯å¦å­˜åœ¨ä¸”ç©ºé—²

åˆå¹¶å¤§å°ï¼šå½“å‰å—å¤§å° += åç»§å—å¤§å°

é“¾è¡¨æ›´æ–°ï¼š

plaintext
å‰: [A] â†’ [B] â†’ [C]
å: [A+B] â†’ [C] (å…¶ä¸­A.next = C, C.prev = A)
2. å†…å­˜æ± æ ¸å¿ƒç±» (MemoryPool)
2.1 ç§æœ‰æˆå‘˜
cpp
private:
    MemoryBlock* head;          // å—é“¾è¡¨å¤´
    char* pool_start;           // å†…å­˜æ± èµ·å§‹åœ°å€
    char* pool_end;             // å½“å‰åˆ†é…ä½ç½®
    size_t pool_total_size;     // å†…å­˜æ± æ€»å®¹é‡
å†…å­˜å¸ƒå±€ï¼š

plaintext
0x0000 [pool_start]
       â”œâ”€â”€ MemoryBlock1 (å¤´èŠ‚ç‚¹)
       â”œâ”€â”€ ç”¨æˆ·æ•°æ®åŒº1
       â”œâ”€â”€ MemoryBlock2
       â”œâ”€â”€ ç”¨æˆ·æ•°æ®åŒº2
       â””â”€â”€ ... 
0xFFFF [pool_start + pool_total_size]
2.2 å—åˆ›å»ºå‡½æ•°
cpp
MemoryBlock* create_block(size_t size, MemoryBlock* prev, MemoryBlock* next) 
{
    // è¾¹ç•Œæ£€æŸ¥ï¼šåˆ†é…åæ˜¯å¦è¶…å‡ºå†…å­˜æ± 
    if (pool_end + size > pool_start + pool_total_size) {
        throw std::bad_alloc();
    }
    
    // åœ¨å½“å‰åˆ†é…ä½ç½®åˆ›å»ºæ–°å—
    MemoryBlock* block = reinterpret_cast<MemoryBlock*>(pool_end);
    block->initialize(size, true, prev, next);
    
    // ç§»åŠ¨åˆ†é…æŒ‡é’ˆ
    pool_end += size;
    return block;
}
å…³é”®ç‚¹ï¼š

çº¿æ€§åˆ†é…ï¼šé€šè¿‡pool_endæŒ‡é’ˆé€’å¢å®ç°O(1)åˆ†é…

å†…å­˜è¦†ç›–æ£€æŸ¥ï¼šç¡®ä¿ä¸è¶…å‡ºé¢„åˆ†é…ç¼“å†²åŒº

2.3 å—åˆ†å‰²å‡½æ•°
cpp
void split_block(MemoryBlock* block, size_t requested_size) 
{
    size_t remaining = block->size - requested_size;
    
    // æ£€æŸ¥å‰©ä½™ç©ºé—´æ˜¯å¦è¶³å¤Ÿæ–°å—ï¼ˆæ§åˆ¶å¤´+æœ€å°æ•°æ®åŒºï¼‰
    if (remaining >= sizeof(MemoryBlock) + 8) 
    {
        // è®¡ç®—åˆ†å‰²ç‚¹åœ°å€
        MemoryBlock* new_block = reinterpret_cast<MemoryBlock*>(
            reinterpret_cast<char*>(block) + requested_size);
        
        // åˆå§‹åŒ–æ–°å—
        new_block->initialize(remaining, true, block, block->next);
        
        // æ›´æ–°é“¾è¡¨
        if (block->next) {
            block->next->prev = new_block;
        }
        block->next = new_block;
        block->size = requested_size;  // è°ƒæ•´åŸå—å¤§å°
    }
}
åˆ†å‰²ç­–ç•¥ï¼š

æœ€å°åˆ†å‰²æ¡ä»¶ï¼šå‰©ä½™ç©ºé—´ >= 40(æ§åˆ¶å¤´) + 8(æœ€å°ç”¨æˆ·æ•°æ®)

åˆ†å‰²åï¼š

plaintext
åˆ†å‰²å‰: [å—A | ç©ºé—²ç©ºé—´]
åˆ†å‰²å: [å—A (requested_size) | å—B (å‰©ä½™ç©ºé—´)]
2.4 æ„é€ å‡½æ•°
cpp
MemoryPool(void* buffer, size_t size) 
    : head(nullptr), pool_total_size(size) 
{
    // ç±»å‹è½¬æ¢ï¼švoid* â†’ char* (å­—èŠ‚æŒ‡é’ˆ)
    pool_start = static_cast<char*>(buffer);
    pool_end = pool_start;
    
    // åˆ›å»ºåˆå§‹å—ï¼šè¦†ç›–æ•´ä¸ªå†…å­˜æ± 
    head = create_block(size, nullptr, nullptr);
}
åˆå§‹åŒ–æµç¨‹ï¼š

è®°å½•ç¼“å†²åŒºèµ·å§‹åœ°å€å’Œæ€»å¤§å°

åˆ›å»ºå•ä¸ªç©ºé—²å—ï¼ˆå¤§å°=æ•´ä¸ªå†…å­˜æ± ï¼‰

2.5 å†…å­˜åˆ†é…
cpp
void* allocate(size_t size) 
{
    if (size == 0) return nullptr;
    
    // 8å­—èŠ‚å¯¹é½è®¡ç®—
    size_t aligned_size = (size + 7) & ~7;
    size_t total_size = aligned_size + sizeof(MemoryBlock);
    
    // æœ€ä½³é€‚åº”æœç´¢
    MemoryBlock* best_fit = nullptr;
    MemoryBlock* block = head;
    
    while (block) {
        if (block->is_free && block->size >= total_size) 
        {
            // å¯»æ‰¾æœ€å°æ»¡è¶³å—
            if (!best_fit || block->size < best_fit->size) {
                best_fit = block;
            }
        }
        block = block->next;
    }
åˆ†é…ç­–ç•¥ï¼š

å¯¹é½è®¡ç®—ï¼š(size+7) & ~7 ç­‰æ•ˆäº ceil(size/8)*8

æ€»éœ€æ±‚ï¼šç”¨æˆ·å¤§å° + æ§åˆ¶å¤´å¤§å°

æœç´¢ç®—æ³•ï¼šæœ€ä½³é€‚åº”ï¼ˆæœ€å°æ»¡è¶³å—ï¼‰

cpp
    // é¦–æ¬¡æœç´¢å¤±è´¥åˆ™åˆå¹¶åé‡è¯•
    if (!best_fit) {
        coalesce();  // å…¨å±€åˆå¹¶ç©ºé—²å—
        // é‡æ–°æœç´¢...
    }
    
    // åˆ†å‰²å—ï¼ˆå¦‚å¯èƒ½ï¼‰
    split_block(best_fit, total_size);
    
    // æ ‡è®°ä¸ºå·²åˆ†é…
    best_fit->is_free = false;
    
    return best_fit->data_ptr;
}
åˆ†é…åå¤„ç†ï¼š

è§¦å‘åˆå¹¶ï¼šå½“é¦–æ¬¡åˆ†é…å¤±è´¥æ—¶å°è¯•åˆå¹¶ç¢ç‰‡

å—åˆ†å‰²ï¼šä¼˜åŒ–å†…å­˜åˆ©ç”¨ç‡

è¿”å›æ•°æ®åŒºæŒ‡é’ˆï¼ˆè·³è¿‡æ§åˆ¶å¤´ï¼‰

2.6 å†…å­˜é‡Šæ”¾
cpp
void deallocate(void* ptr) 
{
    if (!ptr) return;
    
    // ä»æ•°æ®æŒ‡é’ˆåæ¨æ§åˆ¶å¤´ä½ç½®
    MemoryBlock* block = reinterpret_cast<MemoryBlock*>(
        reinterpret_cast<char*>(ptr) - sizeof(MemoryBlock));
    
    // æ ‡è®°ä¸ºç©ºé—²
    block->is_free = true;
    
    // ç«‹å³åˆå¹¶ç›¸é‚»ç©ºé—²å—
    coalesce();
}
å…³é”®è®¡ç®—ï¼š

(char*)ptr - sizeof(MemoryBlock)ï¼šè·å–æ§åˆ¶å¤´åœ°å€

é‡Šæ”¾åç«‹å³åˆå¹¶ï¼Œå‡å°‘ç¢ç‰‡

2.7 å—åˆå¹¶ç®—æ³•
cpp
void coalesce() 
{
    MemoryBlock* block = head;
    while (block) 
    {
        if (block->is_free && block->next && block->next->is_free) 
        {
            // åˆå¹¶åˆ°å½“å‰å—
            block->size += block->next->size;
            block->next = block->next->next;
            
            if (block->next) {
                block->next->prev = block;
            }
            // æ³¨æ„ï¼šä¸ç§»åŠ¨æŒ‡é’ˆï¼Œç»§ç»­æ£€æŸ¥æ–°åˆå¹¶å—
        }
        else {
            block = block->next;  // ç§»åŠ¨åˆ°ä¸‹ä¸€å—
        }
    }
}
åˆå¹¶ç‰¹ç‚¹ï¼š

å‰å‘åˆå¹¶ï¼šåªåˆå¹¶åç»§å—ï¼ˆå› å•å‘éå†ï¼‰

çº§è”åˆå¹¶ï¼šåˆå¹¶åä¸ç§»åŠ¨æŒ‡é’ˆï¼Œå¯èƒ½è¿ç»­åˆå¹¶å¤šä¸ªå—

æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œnä¸ºå—æ•°é‡

2.8 è¯Šæ–­åŠŸèƒ½
cpp
void print_diagnostics() const 
{
    size_t total_used = 0;   // æ‰€æœ‰å—æ€»å¤§å°
    size_t user_used = 0;    // å·²åˆ†é…ç”¨æˆ·æ•°æ®
    size_t user_free = 0;    // ç©ºé—²ç”¨æˆ·æ•°æ®
    size_t overhead = 0;     // æ§åˆ¶å¤´æ€»å¼€é”€
    ...
    
    // éå†é“¾è¡¨ç»Ÿè®¡
    while (block) {
        size_t user_size = block->size - sizeof(MemoryBlock);
        overhead += sizeof(MemoryBlock);
        
        if (block->is_free) {
            user_free += user_size;
            blocks_free++;
        } else {
            user_used += user_size;
            blocks_used++;
        }
        total_used += block->size;
    }
    
    // ç¢ç‰‡ç‡è®¡ç®—
    double fragmentation = 0.0;
    if (user_free > 0) {
        fragmentation = (1.0 - (double)max_free_block / user_free) * 100.0;
    }
}
è¯Šæ–­æŒ‡æ ‡ï¼š

ç®¡ç†å¼€é”€ï¼šæ‰€æœ‰æ§åˆ¶å¤´æ€»å¤§å°

æœªåˆ†é…å†…å­˜ï¼šæ€»å†…å­˜æ±  - å·²åˆ†é…å—æ€»å’Œ

ç¢ç‰‡ç‡ï¼š(1 - æœ€å¤§ç©ºé—²å—/æ€»ç©ºé—²) Ã— 100%

æœ€å¤§ç©ºé—²å—ï¼šå¯ç”¨äºè¯„ä¼°åˆ†é…èƒ½åŠ›

3. æµ‹è¯•ç”¨ä¾‹åˆ†æ
3.1 å†…å­˜æ± åˆå§‹åŒ–
cpp
static char buffer[1024 * 1024];  // 1MBé™æ€ç¼“å†²åŒº
MemoryPool pool(buffer, sizeof(buffer));
å†…å­˜å¸ƒå±€åˆå§‹åŒ–ï¼š

plaintext
0x0000: [MemoryBlockå¤´]
        size = 1048576 (1MB)
        is_free = true
        data_ptr = 0x0000 + 40 = 0x0028
0xFFFF: ç»“æŸåœ°å€
3.2 åˆ†é…æµ‹è¯•
cpp
void* p1 = pool.allocate(128); // å®é™…åˆ†é…ï¼š128+40=168å­—èŠ‚
åˆ†é…è¿‡ç¨‹ï¼š

å¯¹é½è®¡ç®—ï¼š128 â†’ 128 (å·²æ˜¯8å€æ•°)

æ€»å¤§å°ï¼š128 + 40 = 168å­—èŠ‚

ä»åˆå§‹å—åˆ‡å‰²168å­—èŠ‚

åˆ†å‰²åï¼š

åˆ†é…å—ï¼š168å­—èŠ‚ï¼ˆ40å¤´+128æ•°æ®ï¼‰

å‰©ä½™å—ï¼š1048576-168=1048408å­—èŠ‚

3.3 é‡Šæ”¾æµ‹è¯•
cpp
pool.deallocate(p1);
é‡Šæ”¾è¿‡ç¨‹ï¼š

è®¡ç®—æ§åˆ¶å¤´åœ°å€ï¼šp1 - 40

æ ‡è®°ä¸ºfree

æ‰§è¡Œåˆå¹¶ï¼š

æ£€æŸ¥å‰é©±ï¼šæ— 

æ£€æŸ¥åç»§ï¼šç©ºé—² â†’ åˆå¹¶

æ¢å¤ä¸ºå•ä¸€å—
